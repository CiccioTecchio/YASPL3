package parser;

import java_cup.runtime.*;
import syntax_tree.*;

/*List of terminals*/
terminal HEAD;
terminal START;
terminal SEMI;
terminal String BOOL;
terminal String DOUBLE;
terminal String STRING;
terminal String CHAR;
terminal String ID;
terminal COMMA;
terminal DEF;
terminal LPAR;
terminal RPAR;
terminal LGPAR;
terminal RGPAR;
terminal READ;
terminal WRITE;
terminal char PLUS;
terminal char MINUS;
terminal char TIMES;
terminal char DIV;
terminal String INT_CONST;
terminal String DOUBLE_CONST;
terminal String STRING_CONST;
terminal String CHAR_CONST;
terminal TRUE;
terminal FALSE;
terminal ASSIGN;
terminal IF;
terminal THEN;
terminal WHILE;
terminal DO;
terminal ELSE;
terminal GT;
terminal GE;
terminal LT;
terminal LE;
terminal EQ;
terminal NOT;
terminal AND;
terminal OR;
terminal IN;
terminal OUT;
terminal INOUT;
terminal INT;
terminal UMINUS; /*is the Symbol '-'  used for unary operation*/ 


/*List of non teminals*/  
non terminal	Operation	Programma; 
non terminal	Operation 	Decls;
non terminal	Operation 	Statements; 
non terminal	Operation	Var_decl;
non terminal	String		Type;
non terminal	Operation	Var_decls_init;
non terminal	Operation	Var_init_value;
non terminal	Node		Vars;
non terminal	Operation	Def_decl;
non terminal	Operation	Var_decls;
non terminal	Operation	Par_decls;  
non terminal	Node		Par_type;
non terminal	Operation	Body;
non terminal	Operation	Stat;
non terminal	Operation	Args;
non terminal	Operation	Comp_stat;
non terminal	Node		Expr;

/*List of precedences*/ 

precedence nonassoc  ELSE; 
precedence left PLUS,MINUS,OR;
precedence left TIMES,DIV,AND;
precedence nonassoc GT, GE, LT, LE, EQ; 
precedence left UMINUS, NOT, COMMA;


/*Grammar*/														/*Sostituire Operation op con RESULT = new ecc...*/
Programma 	::= HEAD Decls:decls START Statements:statements 	{: Operation op = new Operation("ProgramOp", decls, statements);
																//System.out.println(op.getOp()); 
																RESULT = op; :};
																
Decls 		::= Var_decl:var_decl Decls:decls					{: Operation op = new Operation("DeclsOp", var_decl, decls);
																//System.out.println(op.getOp()+" prima"); 
																RESULT = op; :}
			|	Def_decl:def_decl Decls:decls					{: Operation op = new Operation("DeclsOp", def_decl, decls);
																//System.out.println(op.getOp());
																RESULT = op; :}
			|	{: RESULT = null; :} /*epsilon*/		
			;
Statements	::=	Stat Statements
			|	{: RESULT = null; :} /*epsilon*/
			;
Var_decl	::=	Type:tp Var_decls_init SEMI; 
Type		::=	INT 	{: RESULT = "Type_Int"; :}
			|	BOOL 	{: RESULT = "Type_Bool"; :}
			|	DOUBLE 	{: RESULT = "Type_Double"; :}
			|	STRING 	{: RESULT = "Type_String"; :}
			|	CHAR 	{: RESULT = "Type_Char"; :}
			;
Var_decls_init	::=	ID:id Var_init_value:viv COMMA Var_decls_init:vdi	{:
																		Node n = new Node(id); 
																		RESULT = new Operation("VarDeclsInit", n , viv, vdi);
																		:}
				|	ID:id Var_init_value:viv							{:
																		Node n = new Node(id); 
																		RESULT = new Operation("VarDeclsInit", n, viv);
																		:}
				;
Var_init_value	::= ASSIGN Expr:e1 {: RESULT = new Operation("VarInitValueOp",e1); :}
				|	{: RESULT = null; :} /*epsilon*/
				;
Vars		::=	ID:id COMMA Vars:vars 	{: RESULT = ((Operation)vars).addChild(new Leaf("ID",id)); :}
			|	ID:id 					{: Leaf l = new Leaf("ID",id);
										   RESULT = new Operation("VarsOp",l); :}
			;
Def_decl	::=	DEF ID LPAR Par_decls RPAR Body
			|	DEF ID LPAR RPAR Body
			;
Var_decls	::=	Var_decl Var_decls
			| 	{: RESULT = null; :} /*epsilon*/
			;
Par_decls	::=	Par_type:parType Type:type ID:id COMMA Par_decls:parDecls {:
																			Node n1 = new Node(type); 
																			Node n2 = new Node(id);
																			RESULT = new Operation("ParOp", parType, n1, n2, parDecls);
																			:}
			|	Par_type:par Type:type ID:id				{:	Node n1 = new Node(type); 
																Node n2 = new Node(id);
																RESULT = new Operation("ParOp",par, n1, n2); 
															:}
			;
Par_type	::=	IN		{: RESULT = new Leaf("IN", "in"); :}
			|	OUT		{: RESULT = new Leaf("OUT", "out"); :}
			|	INOUT	{: RESULT = new Leaf("INOUT", "inout"); :}
			;
Body		::=	LGPAR Var_decls Statements RGPAR;
Stat		::= Vars:vars READ SEMI						{: RESULT = new Operation("ReadOp", vars); :}
			|	Args:args WRITE SEMI				{: RESULT = new Operation("WriteOp", args); :}
			|	ID:id ASSIGN Expr:e1 SEMI 			{:  Leaf l = new Leaf("ID",id);
														RESULT = new Operation("AssignOp",l,e1); :}
			|	ID:id LPAR Args:args RPAR SEMI		{: 	Leaf l = new Leaf("ID", id);
														RESULT = new Operation("CallOp", l, args ); 
													:}
			|	ID:id LPAR RPAR SEMI					{: RESULT = new Operation("CallOp", new Leaf("ID", id)); :}
			|	IF LPAR Expr RPAR THEN Comp_stat ELSE Comp_stat
			|	IF LPAR Expr RPAR THEN Comp_stat
			|	WHILE LPAR Expr RPAR DO Comp_stat
			;
Args		::=	Expr:e1 COMMA Args:arg1	{: RESULT = arg1.addChild(e1); :}
			|	Expr:e1					{: RESULT = new Operation("Args", e1); :}
			;
			
Comp_stat	::=	LGPAR Statements RGPAR;

Expr		::=	Expr:e1 PLUS Expr:e2 			{: RESULT = new Operation("AddOp", e1, e2); :}
			|	Expr:e1 MINUS Expr:e2			{: RESULT = new Operation("SubOp", e1, e2); :}
			|	Expr:e1 TIMES Expr:e2			{: RESULT = new Operation("MultOp", e1, e2); :}
			|	Expr:e1 DIV Expr:e2				{: RESULT = new Operation("DivOp", e1, e2); :}
			|	Expr:e1 AND Expr:e2				{: RESULT = new Operation("AndOp", e1, e2); :}
			|	Expr:e1 OR Expr:e2				{: RESULT = new Operation("OrOp", e1, e2); :}
			|	Expr:e1 GT Expr:e2				{: RESULT = new Operation("GtOp", e1, e2); :}
			|	Expr:e1 GE Expr:e2				{: RESULT = new Operation("GeOp", e1, e2); :}
			|	Expr:e1 LE Expr:e2				{: RESULT = new Operation("LeOp", e1, e2); :}
			|	Expr:e1 LT Expr:e2				{: RESULT = new Operation("LtOp", e1, e2); :}
			|	Expr:e1 EQ Expr:e2				{: RESULT = new Operation("EqOp", e1, e2); :}
			|	MINUS Expr:e1 					{: RESULT = new Operation("Uminus", e1); :} %prec UMINUS		
			|	NOT Expr:e1						{: RESULT = new Operation("NotOp", e1); :}
			|	LPAR Expr:e1 RPAR				{: RESULT = e1; :}
			|	TRUE							{: RESULT = new Leaf("TRUE","true"); :}
			|	FALSE							{: RESULT = new Leaf("FALSE","false"); :}
			|	ID:id							{: RESULT = new Leaf("ID", id); :}
			|	INT_CONST:intConst 				{: RESULT = new Leaf("INT_CONST", intConst); :}
			|	DOUBLE_CONST:doubleConst		{: RESULT = new Leaf("DOUBLE_CONST", doubleConst); :}
			|	CHAR_CONST:charConst			{: RESULT = new Leaf("CHAR_CONST", charConst); :}
			|	STRING_CONST:stringConst 		{: RESULT = new Leaf("STRING_CONST", stringConst); :}
			;									
