package parser;


import java_cup.runtime.*;
import syntaxTree.*;  
import syntaxTree.arithOp.*;
import syntaxTree.comp.*;
import syntaxTree.logicOp.*;
import syntaxTree.relOp.*;
import syntaxTree.statOp.*;
import syntaxTree.wrapper.*;
import visitor.*;

/*List of terminals*/
terminal HEAD;
terminal START;
terminal SEMI;
terminal BOOL;
terminal DOUBLE;
terminal STRING;
terminal CHAR;
terminal String ID;
terminal COMMA;
terminal DEF;
terminal LPAR;
terminal RPAR;
terminal LGPAR;
terminal RGPAR;
terminal READ;
terminal WRITE; 
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIV;
terminal String INT_CONST;
terminal String DOUBLE_CONST;
terminal String STRING_CONST;
terminal String CHAR_CONST;
terminal TRUE;
terminal FALSE;
terminal ASSIGN;
terminal IF;
terminal THEN;
terminal WHILE;
terminal DO;
terminal ELSE;
terminal GT;
terminal GE;
terminal LT;
terminal LE;
terminal EQ;
terminal NOT;
terminal AND;
terminal OR;
terminal IN;
terminal OUT;
terminal INOUT;
terminal INT;
terminal UMINUS; /*is the Symbol '-'  used for unary Internal*/ 


/*List of non teminals*/  
non terminal	Programma			Programma; 
non terminal	Decls		 		Decls;
non terminal	Statements			Statements; 
non terminal	VarDecl				Var_decl;
non terminal	Leaf				Type;
non terminal	VarDeclsInit		Var_decls_init;
non terminal	VarInitValue		Var_init_value;
non terminal	Vars				Vars;
non terminal	DefDecl				Def_decl;
non terminal	VarDecls			Var_decls;
non terminal	ParDecls			Par_decls;  
non terminal	Leaf				Par_type;
non terminal	Body				Body;
non terminal	Stat				Stat;
non terminal	Args				Args;
non terminal	CompStat			Comp_stat;
non terminal	Expr				Expr;
/*List of precedences*/ 

precedence nonassoc  ELSE; 
precedence left PLUS,MINUS,OR;
precedence left TIMES,DIV,AND;
precedence nonassoc GT, GE, LT, LE, EQ; 
precedence left UMINUS, NOT, COMMA;	

/*Grammar*/												
Programma 	::= HEAD Decls:decls START Statements:s	{:	RESULT = new Programma("ProgrammaOp", decls, s); 
														TreePrinterVisitor tpv = new TreePrinterVisitor();
														System.out.println(tpv.visit(RESULT));:}
			; 
																
Decls 		::= Var_decl:var Decls:decls								{: RESULT = decls.addChild(var); :}
			|	Def_decl:def Decls:decls								{: RESULT = decls.addChild(def); :}
			|	/*epsilon*/												{: RESULT = new Decls("DeclsOp"); :}		
			;
Statements	::=	Stat:s Statements:stmt									{: RESULT = stmt.addChild(s); :}
			|	 /*epsilon*/											{: RESULT = new Statements("StatementsOp"); :}
			;
Var_decl	::=	Type:tp Var_decls_init:vdi SEMI							{: RESULT = new VarDecl("VarDeclOp", tp, vdi); :}
			; 
Type		::=	INT 	{: RESULT = new Leaf("Type", "INT"); :}
			|	BOOL 	{: RESULT = new Leaf("Type", "BOOL"); :}
			|	DOUBLE 	{: RESULT = new Leaf("Type", "DOUBLE"); :}
			|	STRING 	{: RESULT = new Leaf("Type", "STRING"); :}
			|	CHAR 	{: RESULT = new Leaf("Type", "CHAR"); :}
			;
			
Var_decls_init	::=	ID:id Var_init_value:viv COMMA Var_decls_init:vdi	{: VarDeclsInitWrapper vdiw = (viv == null)? new VarDeclsInitWrapper("VarNotInitOp", new Leaf("ID",id))
																												   : new VarDeclsInitWrapper("VarInitOp", new Leaf("ID",id), viv);
																			RESULT = vdi.addChild(vdiw); :}
				|	ID:id Var_init_value:viv							{: VarDeclsInitWrapper vdiw = (viv == null)? new VarDeclsInitWrapper("VarNotInitOp", new Leaf("ID",id))
																												   : new VarDeclsInitWrapper("VarInitOp", new Leaf("ID",id), viv);
																			RESULT = new VarDeclsInit("VarDeclInit").addChild(vdiw); :}
				;
Var_init_value	::= ASSIGN Expr:e										{: RESULT = new VarInitValue("VarInitValueOp", e); :}
				|	/*epsilon*/											{: RESULT = null; :}
				;
Vars		::=	ID:id COMMA Vars:vars									{: RESULT = vars.addChild(new Leaf("ID",id)); :}
			|	ID:id													{: RESULT = new Vars("VarsOp").addChild(new Leaf("ID",id)); :}
			;
Def_decl	::=	DEF ID:id LPAR Par_decls:par RPAR Body:b				{: RESULT = new DefDecl("DefDeclWithPar", new Leaf("ID",id), par ,b); :}
			|	DEF ID:id LPAR RPAR Body:b								{: RESULT = new DefDecl("DefDeclNoPar", new Leaf("ID",id), b); :}
			;
Var_decls	::=	Var_decl:vd Var_decls:vds								{: RESULT = vds.addChild(vd); :}
			|	/*epsilon*/												{: RESULT = new VarDecls("VarDeclsOp"); :}
			;
Par_decls	::=	Par_type:par Type:type ID:id COMMA Par_decls:parDecls	{: RESULT = parDecls.addChild( new ParDeclSon ("ParDeclSon", par, type, new Leaf("ID",id))); :}
			|	Par_type:par Type:type ID:id							{: RESULT = new ParDecls("ParDeclsOp").addChild( new ParDeclSon ("ParDeclSon", par, type, new Leaf("ID",id))); :}
			;
			
Par_type	::=	IN		{: RESULT = new Leaf("ParType", "in"); :}
			|	OUT		{: RESULT = new Leaf("ParType", "out"); :}
			|	INOUT	{: RESULT = new Leaf("ParType", "inout"); :}
			;
			
Body		::=	LGPAR Var_decls:vd Statements:s RGPAR						{: RESULT = new Body("BodyOp", vd, s); :}	
			;
			
Stat		::= Vars:vars READ SEMI											{: RESULT = new ReadOp("ReadOp", vars); :}
			|	Args:args WRITE SEMI										{: RESULT = new WriteOp("WriteOp", args); :}
			|	ID:id ASSIGN Expr:e SEMI 									{: RESULT = new AssignOp("AssignOp", new Leaf("ID",id), e); :}
			|	ID:id LPAR Args:args RPAR SEMI								{: RESULT = new CallOp("CallOp",new Leaf("ID",id),args); :}
			|	ID:id LPAR RPAR SEMI									 	{: RESULT = new CallOp("CallOp", new Leaf("ID",id)); :}
			|	IF LPAR Expr:e RPAR THEN Comp_stat:cs1 ELSE Comp_stat:cs2	{: RESULT = new IfThenElseOp("IfThenElseOp",e, cs1, cs2); :}
			|	IF LPAR Expr:e RPAR THEN Comp_stat:cs 						{: RESULT = new IfThenOp("IfThenOp",e,cs); :}
			|	WHILE LPAR Expr:e RPAR DO Comp_stat:cs						{: RESULT = new WhileOp("WhileOp", e, cs); :}
			;
			
Args		::=	Expr:e COMMA Args:arg		{: RESULT = arg.addChild(e); :}
			|	Expr:e						{: RESULT = new Args("ArgsOp").addChild(e); :}				
			;
			
Comp_stat	::=	LGPAR Statements:s RGPAR 	{: RESULT = new CompStat("CompStat", s); :}
			;

Expr		::=	Expr:e1 MINUS Expr:e2		{: RESULT = new SubOp("SubOp", e1, e2); :}	
			|	Expr:e1 PLUS Expr:e2 		{: RESULT = new AddOp("AddOp", e1, e2); :}
			|	Expr:e1 TIMES Expr:e2		{: RESULT = new MultOp("MultOp", e1, e2);:}	
			|	Expr:e1 DIV Expr:e2			{: RESULT = new DivOp("DivOp", e1, e2); :}
			|	Expr:e1 AND Expr:e2			{: RESULT = new AndOp("AndOp", e1, e2); :}	
			|	Expr:e1 OR Expr:e2			{: RESULT = new OrOp("OrOp", e1, e2); :}
			|	Expr:e1 GT Expr:e2			{: RESULT = new GtOp("GtOp", e1, e2); :}
			|	Expr:e1 GE Expr:e2			{: RESULT = new GeOp("GeOp", e1, e2); :}	
			|	Expr:e1 LE Expr:e2			{: RESULT = new LeOp("LeOp", e1, e2); :}	
			|	Expr:e1 LT Expr:e2			{: RESULT = new LtOp("LtOp", e1, e2); :}
			|	Expr:e1 EQ Expr:e2			{: RESULT = new EqOp("EqOp", e1, e2); :}	
			|	MINUS Expr:e 				{: RESULT = new UminusOp("UminusOp", e); :} %prec UMINUS			
			|	NOT Expr:e					{: RESULT = new NotOp("NotOp", e); :}
			|	LPAR Expr:e RPAR			{: RESULT = e; :}
			|	TRUE						{: RESULT = new Expr("BOOL_CONST", "true"); :}
			|	FALSE						{: RESULT = new Expr("BOOL_CONST", "false"); :}	
			|	ID:id						{: RESULT = new Expr("ID", id); :}
			|	INT_CONST:intConst 			{: RESULT = new Expr("INT_CONST", intConst); :}	
			|	DOUBLE_CONST:doubleConst	{: RESULT = new Expr("DOUBLE_CONST", doubleConst); :}	
			|	CHAR_CONST:charConst		{: RESULT = new Expr("CHAR_CONST", charConst); :}
			|	STRING_CONST:stringConst 	{: RESULT = new Expr("STRING_CONST", stringConst); :}	
			;									
